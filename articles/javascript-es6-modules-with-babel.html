<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="UTF-8" />
    <title>ES2015 (ES6) Modules with Babel</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.3/normalize.css" />
    <link rel="stylesheet" href="/css/main.css" />
    <link href='https://fonts.googleapis.com/css?family=Abril+Fatface|Open+Sans:300,400,700' rel='stylesheet' type='text/css' />

    

    

</head>

<body>
    
    <div class="page">

        

        <div class="primary-content">

            <input type="checkbox" id="toggle-menu">
<label for="toggle-menu" class="toggle-menu off"></label>

<aside class="primary-aside">
    <nav>
        <a href="/">Welcome</a>
        <a href="/community">Community</a>
        <a href="/articles">Articles</a>
        <a href="/talks">Talks</a>
        <a href="https://www.sitepoint.com/premium/users/bWestfall">Sitepoint</a>
        <a href="https://www.youtube.com/channel/UCZi-0WJPUNb_LQocFMJw5dA/videos">YouTube</a>
        <a href="http://azpixels.com">Work</a>
    </nav>
    <label for="toggle-menu" class="toggle-menu on">Menu</label>
</aside>

            <main>
                
                
                <article>
    <header>
        <h1>ES2015 (ES6) Modules with Babel</h1>
        <time datetime="2016-03-07">2016-03-07</time>
    </header>
    <p class="intro">Every once in a while, a third-party tool or concept is so compelling that it eventually makes its way into the standard. This is what happened with CommonJS and ES2015 (ES6) modules.</p>

<p>While ES2015 module syntax differs from CommonJS, it&#39;s clear that it was influenced by, and designed to be compatible with CommonJS.</p>
<p>From the <code>import</code> standpoint, here&#39;s how the new ES2015 syntax looks in comparison:</p>
<pre><code class="language-js">// CommonJS
var express = require(&#39;express&#39;);

// ES2015
import express from &#39;express&#39;;
</code></pre>
<p class="footnote">At the time of this writing, Node does not support ES2015 modules. You must use a transpiler such as <a href="http://babeljs.io/">Babel</a> to use them. If you want to use this syntax for the browser, use Babel with a bundler like Webpack or Browserify</p>

<p>Import statements can consume anything from a CommonJS <code>module.exports</code> which means all modules written in CommonJS are instantly compatible with ES2015 modules.</p>
<p>There are a few things that make the new syntax compelling over CommonJS, including its ability to do multiple exports and some interesting new patterns with destructuring.</p>
<p>This article doesn&#39;t focus so much on teaching why one would want to use modules, but rather as a contrast between CommonJS and ES2015 modules.</p>
<h2>Multiple Exports</h2><p>CommonJS only allows for one thing to be exported, which means that if the developer wanted to export multiple functions, they would need to export an object methods instead:</p>
<pre><code class="language-js">// first-example.js

module.exports = {
    foo: function() { ... },
    bar: function() { ... },
    ...
};
</code></pre>
<p>One thing that make exporting different in ES2015 modules is their ability to <code>export</code> multiple things from the same file:</p>
<pre><code class="language-js">// second-example.js

export function foo() {
    ...
}

export function bar() {
    ...
}
</code></pre>
<p>However, if we were to <code>import</code> the two examples (the first being a CommonJS export and the second being an ES2015 export), we would get different results:</p>
<pre><code class="language-js">import first from &#39;first-example&#39;;
import second from &#39;second-example&#39;;

console.log(first);  // object
console.log(second); // undefined
</code></pre>
<p>In the <code>second-example.js</code> file, there are multiple exports but none are the &quot;default&quot; export. Instead it has two &quot;named&quot; exports. This causes an <code>undefined</code> to be returned to our variable name with Babel&#39;s interpretation of ES2015 modules.</p>
<p>To import the ES2015 module, we can use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">destructuring</a>, another new ES2015 feature. Destructuring can be used to extract the named <code>foo</code> and <code>bar</code> functions into variables:</p>
<pre><code class="language-js">import { foo, bar } from &#39;second-example&#39;;

foo();
</code></pre>
<p class="footnote">
    Destructuring could have also been used for the <code>first-example.js</code> file to extract the object&#39;s methods just as we did with the <code>second-example.js</code> file.
</p>

<p>Alternatively, the asterisk can be used to import all the named functions into an object:</p>
<pre><code class="language-js">import * as second from &#39;second-example&#39;;

second.foo();
second.bar();
</code></pre>
<p>In this case, the object, <code>second</code>, will contain methods for each named exports from the file. If there were functions in the file that weren&#39;t exported, they won&#39;t become methods of <code>second</code>.</p>
<h2>Default Exports</h2><p>As already suggested, a module can also designate one of its exports as a <code>default</code>. If a file has a <code>default</code> export, then the respective <code>import</code> wouldn&#39;t need to do destructuring or the asterisk syntax:</p>
<pre><code class="language-js">// third-example.js
export function foo() { ... }
export function bar() { ... }
export default function() { ... }
</code></pre>
<pre><code class="language-js">import something from &#39;third-example&#39;;
something() // calls the default
</code></pre>
<p>The variable name <code>something</code> is just an example. Any variable name could have been chosen to load the <code>default</code> export. The main point though is that with this <code>import</code> syntax, we will get the <code>default</code> of the module, and nothing else.</p>
<p>So what if we want to <code>import</code> the default along with <code>foo</code> and <code>bar</code>? It is possible to get all three functions with the <code>import</code>:</p>
<pre><code class="language-js">// first way
import * as myModule from &#39;third-example&#39;;

// second way
import defaultFunc, { foo, bar } from &#39;third-example&#39;;

// third way
import defaultFunc, * as myModule from &#39;third-example&#39;;
</code></pre>
<p><strong>The first way</strong> creates an object called <code>myModule</code> with all three exports as methods. The <code>default</code> export becomes a property name of &quot;defualt&quot;, ie: <code>myModule.default()</code>.</p>
<p><strong>The second way</strong> creates three variables: <code>defaultFunc</code>, <code>foo</code>, and <code>bar</code> using a hybrid of the destructuring way and the default way.</p>
<p><strong>The third way</strong> allows us to create <code>defaultFunc</code> as a normal variable and then an object called <code>myModule</code> which contains all exports as properties (including the default oddly enough)</p>
<h2>Exporting Expressions</h2><p>In the examples so far, exporting functions have come in the form of named function declarations. However, function expression syntax can also be used:</p>
<pre><code class="language-js">// Function Declarations
export function foo() {
    ...
}

// Function Expressions
export const bar = function() {
    ...
}
</code></pre>
<p>While ordinarily the difference between function declarations and expressions is a matter of <a href="http://www.w3schools.com/js/js_hoisting.asp">hoisting</a>, I don&#39;t believe there are any real differences between the two when it comes to modules.</p>
<h2>Other types of exports</h2><p>Modules can also export things other than functions. But all non-default exports need to be named values with <code>var</code>, <code>let</code>, or <code>const</code>. The <code>default</code> export though cannot be named:</p>
<pre><code class="language-js">// All of these are valid
export const foo = &#39;abc&#39;
export const bar = {some: &#39;value&#39;}
export default {some: &#39;value&#39;}

// All of these are invalid
export const &#39;abc&#39;
export bar = {some: &#39;value&#39;}
export default someName = {some: &#39;value&#39;}
</code></pre>
<h2>Modules as a function</h2><p>Many CommonJS modules export a function instead of an object:</p>
<pre><code class="language-js">module.exports = function() {
    ...
}
</code></pre>
<p>This allows consumers of those modules to use the module with <code>require()</code> like this:</p>
<pre><code class="language-js">var someModule = require(&#39;some-module&#39;)()
</code></pre>
<p class="footnote">Notice the extra set of parenthesis at the end.</p>

<p>This code includes the module (which is a function instead of an object) and then calls the function immediately. Then, it&#39;s the result of that function call which is returned to <code>someModule</code>.</p>
<p>Some have wondered how these types of modules will continue to be compatible with ES2015 since the new <code>import</code> syntax cannot allow a returned function to be called immediately in a similar way:</p>
<pre><code class="language-js">// Nope, that&#39;s not valid at all
import someModule from &#39;some-module&#39;();
</code></pre>
<p>However, with the new ES2015 module syntax, if a module exports a function (even if by default), You could do the <code>import</code> in one line and then call the function in the next:</p>
<pre><code class="language-js">import someModuleFactory from &#39;some-module&#39;;
const someModule = someModuleFactory();
</code></pre>
<p>It&#39;s not quite as elegant, but it works.</p>
<h2>Summary</h2><p>For more information, read Mozilla&#39;s documentation on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">import</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export">export</a></p>

</article>
            </main>
        </div>

        <footer>
    <a href="http://twitter.com/bradwestfall">@bradwestfall</a>
</footer>

    </div>
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.0.0-beta1/jquery.min.js"></script>
<script src="/js/prism.js"></script>
<script src="/js/helpers.js"></script>
<script async src="//platform.twitter.com/widgets.js"></script>

</body>
</html>